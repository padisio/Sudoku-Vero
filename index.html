<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>VeruchiDoku</title>
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#0ea5e9" />
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;margin:0;background:#fff;color:#111}
    header{display:flex;justify-content:space-between;align-items:center;gap:.5rem;padding:.75rem 1rem;position:sticky;top:0;background:#fff;border-bottom:1px solid #eee}
    .primary{background:#0ea5e9;color:#fff;border:0;border-radius:.75rem;padding:.5rem .9rem;font-weight:600}
    .levels button{margin-right:.4rem}
    .actions button+button{margin-left:.4rem}
    #app{padding:1rem}
  </style>
</head>
<body>
  <header class="toolbar">
    <div class="levels">
      <button data-level="fácil">Fácil</button>
      <button data-level="media">Media</button>
      <button data-level="difícil">Difícil</button>
      <button data-level="experto">Experto</button>
    </div>
    <div class="actions">
      <button id="new" class="primary">Nueva</button>
      <button id="installApp" class="primary" style="display:none">Instalar</button>
    </div>
  </header>

  <main id="app">
    <!-- Coloca aquí tu tablero/HTML del juego existente -->
  </main>

  <!-- Anti auto-new: no generar puzzle hasta que el usuario pulse "Nueva" -->
  <script>
  (function(){
    const DEF_LEVEL = 'media';
    let _origNewGame = null;
    let allowNewGame = false;
    let queuedAutoArgs = null;

    function hookNewGame(){
      if (typeof window.newGame !== 'function' || _origNewGame) return;
      _origNewGame = window.newGame;
      window.newGame = function(...args){
        if (!allowNewGame){
          queuedAutoArgs = args.length ? args : [DEF_LEVEL];
          console.log('[VDK] Bloqueado newGame() automático; espera al toque de "Nueva"');
          return;
        }
        return _origNewGame.apply(this, args);
      };
    }

    window.addEventListener('DOMContentLoaded', () => {
      hookNewGame();
      const btn = document.getElementById('new');
      if (btn){
        btn.addEventListener('click', () => {
          allowNewGame = true;
          const args = queuedAutoArgs || [DEF_LEVEL];
          _origNewGame && _origNewGame.apply(window, args);
          window.newGame = _origNewGame; // permitir llamadas siguientes
        });
      }
    });
  })();
  </script>

  <!-- Persistencia segura (no toca dados, no auto "Nueva") -->
  <script>
  (function(){
    const SAVE_KEY = 'veruchidoku-save-v5';
    const clone9 = m => (m||[]).map(r => (r||[]).slice());

    function baseFromBoard(){
      const base = Array(9).fill(null).map(()=>Array(9).fill(0));
      if (!window.board) return base;
      for (let r=0;r<9;r++) for (let c=0;c<9;c++){
        const v = window.board[r]?.[c] || 0;
        if (v) base[r][c] = v;
      }
      return base;
    }
    function extractMoves(current, base){
      const moves = [];
      if (!current) return moves;
      for (let r=0;r<9;r++) for (let c=0;c<9;c++){
        const v = current[r]?.[c] || 0;
        if (base[r][c] === 0 && v) moves.push([r,c,v]);
      }
      return moves;
    }
    function applyBase(base){ window.board = clone9(base); }
    function applyMoves(moves, base){
      if (!Array.isArray(moves) || !window.board) return;
      for (const [r,c,v] of moves) if (base[r][c]===0 && window.board[r]) window.board[r][c] = v;
    }

    function saveState(){
      try{
        if (!window.board) return;
        const base = baseFromBoard();
        const data = {
          base,
          moves: extractMoves(window.board, base),
          pencil: !!window.pencil,
          elapsed: typeof window.seconds === 'number' ? window.seconds : 0
        };
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
      }catch(e){ console.warn('[VDK] save error', e); }
    }
    function restoreState(){
      try{
        const raw = localStorage.getItem(SAVE_KEY);
        if (!raw) return false;
        const data = JSON.parse(raw);
        if (!data?.base) return false;
        applyBase(data.base);
        applyMoves(data.moves, data.base);
        if (typeof window.seconds === 'number') window.seconds = data.elapsed || 0;
        window.pencil = !!data.pencil;
        if (typeof window.render === 'function') window.render();
        if (typeof window.renderPad === 'function') window.renderPad();
        console.log('[VDK] restaurado');
        return true;
      }catch(e){ console.warn('[VDK] restore error', e); return false; }
    }

    window.addEventListener('load', () => {
      // Hook: guardar tras acciones reales
      if (typeof window.inputNumber === 'function'){
        const orig = window.inputNumber;
        window.inputNumber = function(n){
          const r = orig.apply(this, arguments);
          setTimeout(saveState, 50);
          return r;
        };
      }
      if (typeof window.newGame === 'function'){
        const origNG = window.newGame;
        window.newGame = function(){
          const r = origNG.apply(this, arguments);
          setTimeout(saveState, 100);
          return r;
        };
      }
      // Restaurar si hay guardado (no crea puzzle si no hay)
      setTimeout(restoreState, 0);
    });

    window.clearSavedGame = () => localStorage.removeItem(SAVE_KEY);
  })();
  </script>

  <!-- PWA: registro SW + botón Instalar -->
  <script>
  (function(){
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js', { scope: '/' })
          .then(r => console.log('[SW] registrado:', r.scope))
          .catch(err => console.error('[SW] error:', err));
      });
    }
    let deferredPrompt = null;
    const btn = document.getElementById('installApp');
    window.addEventListener('beforeinstallprompt', (e) => {
      console.log('[A2HS] beforeinstallprompt');
      e.preventDefault();
      deferredPrompt = e;
      if (btn) btn.style.display = 'inline-block';
    });
    btn?.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      btn.disabled = true;
      try {
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        console.log('[A2HS] outcome:', outcome);
      } finally {
        deferredPrompt = null;
        btn.style.display = 'none';
        btn.disabled = false;
      }
    });
  })();
  </script>
</body>
</html>
